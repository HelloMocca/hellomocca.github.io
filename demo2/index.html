<!doctype html>
<html>
<head>

<script src="./taginfo.js"></script>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
   window.requestAFrame = (function () {
      return window.requestAnimationFrame ||
               window.webkitRequestAnimationFrame ||
               window.mozRequestAnimationFrame ||
               window.oRequestAnimationFrame ||
               // if all else fails, use setTimeout
               function (callback) {
                  return window.setTimeout(callback, 1000 / 60); // shoot for 60 fps
               };
    })();
</script>
<script type="text/javascript">
  var nodes = [];
  var edges = [];
        var canvas = document.querySelector("canvas");
        var context = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        var cooling = canvas.width*.1;
        var totalNodeCount = 0;
        
        init = function(query) {
           var currTagEdge;
           nodes.push(new function() {
              this.name = query;
              this.x = canvas.width/2;
              this.y = canvas.height/2;
              this.dx = 0;
              this.dy = 0;
              this.posX = this.x;
              this.posY = this.y;
              this.r = 2;
           });
           for (var i = 0; i < taginfo.length; i++) {
              currTagEdge = taginfo[i];
              if (currTagEdge[0] == query) {
                 totalNodeCount++;
                 nodes.push(new function() {
                    this.name = currTagEdge[1];
                    this.x = totalNodeCount*20;
                    this.y = 10;
                    this.dx = 0;
                    this.dy = 0;
                    this.posX = totalNodeCount*20;
                    this.posY = 10;
                    this.r = 2;
                 });
                 
                 edges.push({
                    origin: 0,
                    target: totalNodeCount
                 });
                 
              }
           }
            update();
        }
        
        draw = function() {
            for (i = 0; i < nodes.length; i++) {
              nodes[i].posX += (nodes[i].x - nodes[i].posX) / 25;
              nodes[i].posY += (nodes[i].y - nodes[i].posY) / 25;
              context.beginPath();
              context.arc(nodes[i].posX,nodes[i].posY,nodes[i].r,0,Math.PI*2,false);
              context.fillText(nodes[i].name,nodes[i].posX - nodes[i].r, nodes[i].posY+nodes[i].r*2);
              context.closePath();
              context.fill();
            }
            for (i = 0; i < edges.length; i++) {
              nd1 = nodes[edges[i].origin];
              nd2 = nodes[edges[i].target];
              context.beginPath();
              context.moveTo(nd1.posX, nd1.posY);
              context.lineTo(nd2.posX, nd2.posY);
              context.closePath();
              context.stroke();
            }
        };
        update = function() {
            if(cooling < 0.0001) return;
            context.clearRect(0,0,canvas.width, canvas.height);
            var nd1, nd2;
            var i,r;
            //var k = Math.sqrt(canvas.width*canvas.height/nodes.length);
            var k = 50;
            var ex, ey, er;
            aForce = function(er) {return er*er /k};
            rForce = function(er) {return (k*k)/er};
            for (i = 0; i < nodes.length; i++) {
              nodes[i].dx = 0;
              nodes[i].dy = 0;
            }
            //repulsive
            for (i = 0; i < nodes.length-1; i++) {
              nd1 = nodes[i];
              for (r = i+1; r < nodes.length; r++){
                nd2 = nodes[r];
                ex = nd1.x - nd2.x;
                ey = nd1.y - nd2.y;
                er = Math.sqrt(ex*ex + ey*ey); //euclidean distance
                if(er === 0) er = 0.0001;
                fr = rForce(er);
                nd1.dx += ex/er*fr;
                nd1.dy += ey/er*fr;
                nd2.dx -= ex/er*fr;
                nd2.dy -= ey/er*fr;
              }
            }
            //attractive
            for(i = 0; i < edges.length; i++) {
              nd1 = nodes[edges[i].origin];
              nd2 = nodes[edges[i].target];
              ex = nd1.x - nd2.x;
              ey = nd1.y - nd2.y;
              er = Math.sqrt(ex*ex + ey*ey);
              if(er === 0) er = 0.0001;
              fa = aForce(er);
              nd1.dx -= ex/er*fa;
              nd1.dy -= ey/er*fa;
              nd2.dx += ex/er*fa;
              nd2.dy += ey/er*fa;
            }
            //Central
            for (i = 0; i < nodes.length; i++) {
              node = nodes[i];
              ex = canvas.width/2 - node.x;
              ey = canvas.height/2 - node.y;
              er = Math.sqrt(ex*ex + ey*ey);
              if(er === 0) er = 0.0001;
              fa = aForce(er);
              node.dx += ex/er*fa;
              node.dy += ey/er*fa;
            }
            //apply
            for (i = 0; i < nodes.length; i++) {
              er = Math.sqrt(nodes[i].dx * nodes[i].dx + nodes[i].dy * nodes[i].dy);
              nodes[i].x += nodes[i].dx / er * Math.min(er, cooling);
              nodes[i].y += nodes[i].dy / er * Math.min(er, cooling);
            }
            cooling = cooling *.95;
            draw();
            window.requestAFrame(update);
        };
        
        init("트와이스");

</script>
</body>
</html>
