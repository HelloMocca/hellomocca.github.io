<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>movie review similarity</title>
    <style>
        html,body {
           margin:0;padding:0;
            width:100%;
            height:100%;
            overflow:hidden;
        }
        .nodeCanvas {
            position:absolute;
        }

        #canvas {
            position:absolute;
            left:0;
            top:0;
        }

        #infoPanel h1 {
            padding:0;
            margin:0 0 0 25px;
            font-size:25px;
        }

        #infoPanel {
            background-color:rgba(244,244,244,.5)
        }

        #infoPanel:hover {
            background-color:white;
        }
    </style>
</head>
<body>
<canvas id="canvas" width="2400" height="2000"></canvas>
<div id="infoPanel" style="position:fixed; z-index:999; width:250px; height:500px; outline:1px solid #ccc; left:5px; top:5px;">
    <canvas width="200" height="200" id="legends" style="margin:25px 25px 10px 25px;"></canvas>
    <h1>영화이름</h1>
</div><!--
<div style="position:absolute; z-index:998; width:200px; left:0; top:0; height:150px; outline:1px solid #ccc;" >
  <span id="mName">영화이름</span>
</div>-->
<script>
var color = ['#86E57F','#A566FF','#00D8FF','#FFBB00','#FF00DD','#FFFF24'];

var data = null;
var selectedMovie = null;
var legendDrawTimer;
var initLegend = true;
var legendLoop = 0;
var targetWidth = [0,0,0,0,0,0];
var currWidth = [0,0,0,0,0,0];
var numOfMovie = 0;
var numOfProperty = 0;
function updateLegends() {
    var legend = document.querySelector("#legends");
    document.querySelector("#infoPanel h1").innerHTML = "";
    var ctx = legend.getContext('2d');
    if (initLegend) {
        ctx.lineWidth = 1;
        legendLoop = 0;
        currWidth = [0,0,0,0,0,0];
    }
    if (selectedMovie !== null) {
        document.querySelector("#infoPanel h1").innerHTML = selectedMovie.name;
    }
    var i;
    ctx.clearRect(0, 0, legend.clientWidth, legend.clientHeight);
    for(i = 0; i < data[0].children.length; i++) {
        ctx.beginPath();
        ctx.strokeStyle = color[i];
        if (selectedMovie === null) {
            if(initLegend) targetWidth = [50,50,50,50,50,50];
            currWidth[i] += targetWidth[i]/20;
            ctx.lineWidth = currWidth[i];
        } else {
            var total = selectedMovie.positive + selectedMovie.negative;
            var thisPositive = selectedMovie.children[i].positive;
            var thisNegative = selectedMovie.children[i].negative;
            if (initLegend) targetWidth[i] = 60*((thisPositive + thisNegative) / total);
            currWidth[i] += targetWidth[i]/20;
            ctx.lineWidth = currWidth[i];
        }
        ctx.arc(legend.clientWidth/2, legend.clientHeight/2, 40+(ctx.lineWidth/2), (degree360/numOfProperty)*i, (degree360/numOfProperty)*(i+1), false);
        ctx.stroke();
        ctx.beginPath();
        ctx.lineWidth = 5;

        //drawPolarity
        if (selectedMovie === null) ctx.strokeStyle = "grey";
        else {
            if (thisPositive > thisNegative) {
               ctx.strokeStyle = "rgba(0,51,153,"+thisPositive / (thisPositive+thisNegative)+")";
            } else {
                ctx.strokeStyle = "rgba(255,0,0,"+thisNegative / (thisPositive+thisNegative)+")";
            }
        }
        ctx.arc(legend.clientWidth/2, legend.clientHeight/2, 95,  (degree360/numOfProperty)*i + (Math.PI/180 * 2),  (degree360/numOfProperty)*(i+1) - (Math.PI/180 * 2), false);
        ctx.stroke();
    }
    ctx.textBaseline = "middle";
    for(i = 0; i < numOfProperty; i++){
        ctx.save();
        ctx.translate(legend.clientWidth/2, legend.clientHeight/2);
        ctx.rotate((((degree360/numOfProperty) * i) + (degree360/numOfProperty /2)));
        ctx.font = "13px sans-serif";
        ctx.fillText(data[0].children[i].name,50,0);
        ctx.restore();
    }
    legendLoop++;
    if(initLegend) initLegend = false;
    if (legendLoop === 20) {
        initLegend = true;
        legendLoop = 0;
        return;
    }
    legendDrawTimer = setTimeout(updateLegends,1000/60);
}

var mDown = false;
var dragging = false;
var beginOffsetX, beginOffsetY;
var moveOffsetX, moveOffsetY;
var beforePositionX, beforePositionY;
window.addEventListener('load',function(){
    var req = new XMLHttpRequest();
    req.onreadystatechange = function(){
        if (req.readyState == 4) {
            if (req.status == 200) {
                data = JSON.parse(req.responseText).movies;
                numOfMovie = data.length;
                numOfProperty = data[0].children.length;
                updateLegends();
                getSimilarityMatrix();
                getPolarityMatrix();
                initNodes();
                makeEdge();
                update();
                document.addEventListener('mousedown', function(e){
                    mDown = true;
                    beginOffsetX = e.x;
                    beginOffsetY = e.y;
                    beforePositionX = document.querySelector('#canvas').offsetLeft;
                    beforePositionY = document.querySelector('#canvas').offsetTop;
                },false);
                document.addEventListener('mousemove', function(e){
                   if (mDown) {
                       dragging = true;
                       moveOffsetX = e.x - beginOffsetX;
                       moveOffsetY = e.y - beginOffsetY;
                       document.querySelector('#canvas').style.left = beforePositionX+moveOffsetX+"px";
                       document.querySelector('#canvas').style.top = beforePositionY+moveOffsetY+"px";
                   }
                },false);
                document.addEventListener('mouseup', function(e){
                    if(dragging){
                      mDown = false;
                      dragging = false;
                    } else {
                        mDown = false;
                    }
                },false);
                document.querySelector('#canvas').addEventListener('click',function(e){
                    var node;
                    var ex,ey;
                    var i;
                    for (i = 0; i < nodes.length; i++) {
                        node = nodes[i];
                        ex = e.offsetX - node.posX;
                        ey = e.offsetY - node.posY;
                        er = Math.sqrt(ex * ex + ey * ey);
                        if (er < outerRadius) {
                            selectedMovie = data[i];
                            updateLegends();
                            draw();
                            break;
                        }
                    }
                    if (i === nodes.length) {
                        selectedMovie = null;
                        updateLegends();
                        draw();
                    }
                },false);
            }
        }
    };
    req.open("get","reviewScore.json",false);
    req.send();
});

var moviesSimArray = [];
function getSimilarityMatrix() {
    for (var i = 0; i < numOfMovie; i++) {
        //each Movies
        var prop;
        var a = [];
        for (var x = 0; x < data[i].children.length; x++) {
            prop = data[i].children[x];
            a.push( (prop.positive + prop.negative) / (data[i].positive + data[i].negative) );
        }

        var sim = [];
        for (var r = 0; r < data.length; r++) {
            var result = 0;
            var b = [];
            for (var y = 0; y < numOfProperty; y++) {
                prop = data[r].children[y];
                b.push( (prop.positive + prop.negative) / (data[r].positive + data[r].negative) );
            }
            var aVector = 0;
            var bVector = 0;
            for (var z = 0; z < a.length; z++) {
                aVector += a[z] * a[z];
                bVector += b[z] * b[z];
                result += (a[z] * b[z]);
            }
            aVector = Math.sqrt(aVector);
            bVector = Math.sqrt(bVector);
            result = Math.floor((result / (aVector * bVector)) * 100);
            sim.push(result / 100);
        }
        moviesSimArray.push(sim);
    }
}

var polaritySimArray = [];
function getPolarityMatrix() {
    for (var i = 0; i < numOfMovie; i++) {
        var prop;
        var a =[];
        for (var x = 0; x < numOfProperty; x++) {
            prop = data[i].children[x];
            a.push( (prop.positive / prop.positive+prop.negative) );
            a.push( (prop.negative / prop.positive+prop.negative) );
        }

        var sim = [];
        for(var r = 0; r < numOfMovie; r++) {
            var result = 0;
            var b = [];
            for (var y = 0; y < numOfProperty; y++) {
                prop = data[r].children[y];
                b.push( (prop.positive / prop.positive+prop.negative) );
                b.push( (prop.negative / prop.positive+prop.negative) );
            }
            var aVector = 0;
            var bVector = 0;
            for (var z = 0; z < a.length; z++) {
                aVector += a[z] * a[z];
                bVector += b[z] * b[z];
                result += (a[z] * b[z]);
            }
            aVector = Math.sqrt(aVector);
            bVector = Math.sqrt(bVector);
            result = Math.floor((result /(aVector * bVector))*100);
            sim.push(result/100);
        }
        polaritySimArray.push(sim);
    }
}

var edges = [];
var polarityEdges = [];
function makeEdge() {
    edges = [];
    var origin;
    var target;
    for (var i = 0; i < polaritySimArray.length; i++) {
        origin = i;
        for (var r = i+1; r < polaritySimArray[i].length; r++) {
            target = r;
            if (moviesSimArray[i][r] >= .9) {
                edges.push({origin: i, target: r});
                if (polaritySimArray[i][r] >= .9) {
                    polarityEdges.push({origin:i, target: r});
                }
            }
        }
    }
    console.log("num of pEdge :"+edges.length);
}

const degree360 = Math.PI*2;
function initNodes() {
    var nodeCanvas;
    var ctx;
    for (var i = 0; i < data.length; i++) {
        nodes.push(new function() {
            this.name = data[i].name;
            this.x = i*20;
            this.y = 10;
            this.dx = 0;
            this.dy = 0;
            this.posX = i*20;
            this.posY = 10;
            this.r = 10;
        });
//        nodeCanvas = document.createElement("canvas");
//        nodeCanvas.setAttribute("id", "node_"+i);
//        nodeCanvas.setAttribute("class","nodeCanvas");
//        nodeCanvas.setAttribute("width","100");
//        nodeCanvas.setAttribute("height","100");
//        document.body.appendChild(nodeCanvas);
//        nodeCanvas = document.querySelector("#node_"+i);
//        nodeCanvas.addEventListener('click',function(e){
//            selectedMovie = data[this.id.split('_')[1]];
//            updateLegends();
//        });
//        ctx = nodeCanvas.getContext("2d");
//        ctx.lineWidth = 2;
//        var total = data[i].positive + data[i].negative;
//        var x = nodeCanvas.clientWidth/2;
//        var y = nodeCanvas.clientHeight/2;
//        for (var r = 0; r < numOfProperty; r++) {
//            var thisPositive = data[i].children[r].positive;
//            var thisNegative = data[i].children[r].negative;
//            ctx.beginPath();
//            ctx.lineWidth = 35 * ( (thisPositive + thisNegative)/ total);
//            ctx.arc(x, y, 15+(ctx.lineWidth/2), (degree360/numOfProperty) * r, (degree360/numOfProperty) * (r+1), false);
//            ctx.strokeStyle = color[r];
//            ctx.stroke();
//
//            //drawPolarity
//            ctx.lineWidth = 5;
//            ctx.beginPath();
//            ctx.arc(x, y, 40, (degree360/numOfProperty) * r, (degree360/numOfProperty) * (r+1), false);
//            if (thisPositive > thisNegative) {
//              ctx.strokeStyle = "rgba(0,51,153,"+thisPositive / (thisPositive+thisNegative)+")";
//            } else {
//              ctx.strokeStyle = "rgba(255,0,0,"+thisNegative / (thisPositive+thisNegative)+")";
//            }
//            ctx.stroke();
//        }
    }
}

var nodes = [];
var canvas = document.querySelector("#canvas");
var context = canvas.getContext("2d");
var cooling = canvas.width*.1;
var innerRadius = 15;
var outerRadius = 50;
var innerLineWidth = 35;
var outerLineWidth = 5;
var textCondition = 50;
draw = function() {
    context.clearRect(0,0,canvas.width, canvas.height);
    context.save();
    context.strokeStyle = "black";
    context.lineWidth = .05;
    var i;
    for (i = 0; i < polarityEdges.length; i++) {
        if (selectedMovie !== null) {
            if (selectedMovie.name === nodes[polarityEdges[i].origin].name || selectedMovie.name === nodes[polarityEdges[i].target].name) {
                context.strokeStyle = "red";
                context.lineWidth = 1;
            } else {
                context.strokeStyle = "black";
                context.lineWidth = .05;
            }
        }
        nd1 = nodes[polarityEdges[i].origin];
        nd2 = nodes[polarityEdges[i].target];
        context.beginPath();
        context.moveTo(nd1.posX, nd1.posY);
        context.lineTo(nd2.posX, nd2.posY);
        context.closePath();
        context.stroke();
    }
    for (i = 0; i < edges.length; i++) {
        if (selectedMovie !== null) {
            if (selectedMovie.name === nodes[edges[i].origin].name || selectedMovie.name === nodes[edges[i].target].name) {
                context.strokeStyle = "red";
                context.lineWidth = 1;
            } else {
                context.strokeStyle = "black";
                context.lineWidth = .05;
            }
        }
        nd1 = nodes[edges[i].origin];
        nd2 = nodes[edges[i].target];
        context.beginPath();
        context.moveTo(nd1.posX, nd1.posY);
        context.lineTo(nd2.posX, nd2.posY);
        context.closePath();
        context.stroke();
    }
    context.restore();
    for (i = 0; i < nodes.length; i++) {
        nodes[i].posX += (nodes[i].x - nodes[i].posX) / 25;
        nodes[i].posY += (nodes[i].y - nodes[i].posY) / 25;
        context.beginPath();
        context.arc(nodes[i].posX, nodes[i].posY, 10, 0, Math.PI * 2, false);
        context.fillStyle = "black";
        context.fill();
        var total = data[i].positive + data[i].negative;
        for (var r = 0; r < numOfProperty; r++) {
            var thisPositive = data[i].children[r].positive;
            var thisNegative = data[i].children[r].negative;
            context.beginPath();
            context.lineWidth = innerLineWidth * ( (thisPositive + thisNegative)/ total);
            context.arc(nodes[i].posX, nodes[i].posY, innerRadius+(context.lineWidth/2), (degree360/numOfProperty) * r, (degree360/numOfProperty) * (r+1), false);
            context.strokeStyle = color[r];
            context.stroke();

            //drawPolarity
            context.lineWidth = outerLineWidth;
            context.beginPath();
            context.arc(nodes[i].posX, nodes[i].posY, outerRadius, (degree360/numOfProperty) * r + (Math.PI/180 * 2), (degree360/numOfProperty) * (r+1) - (Math.PI/180 * 2), false);
            if (thisPositive > thisNegative) {
                context.strokeStyle = "rgba(0,51,153,"+thisPositive / (thisPositive+thisNegative)+")";
            } else {
                context.strokeStyle = "rgba(255,0,0,"+thisNegative / (thisPositive+thisNegative)+")";
            }
            context.stroke();
        }
        context.font  = "12px sans-serif";
        context.textAlign = "center";

        context.fillText(nodes[i].name,nodes[i].posX, nodes[i].posY+nodes[i].r+textCondition);
//        nodeCanvas = document.querySelector("#node_" + i);
//        nodeCanvas.style.left = (nodes[i].posX - nodeCanvas.clientWidth / 2 ) + "px";
//        nodeCanvas.style.top = (nodes[i].posY - nodeCanvas.clientHeight / 2) + "px";
    }
};

update = function() {
    if(cooling < 0.0001) return;
    var nd1, nd2;
    var i,r;
    var k = Math.sqrt(canvas.width*canvas.height/nodes.length);
    //var k = 150;
    var ex, ey, er;
    aForce = function(er) {return er*er /k};
    rForce = function(er) {return (k*k)/er};
    for (i = 0; i < nodes.length; i++) {
        nodes[i].dx = 0;
        nodes[i].dy = 0;
    }

    //repulsive
    for (i = 0; i < nodes.length-1; i++) {
        nd1 = nodes[i];
        for (r = i+1; r < nodes.length; r++){
            nd2 = nodes[r];
            ex = nd1.x - nd2.x;
            ey = nd1.y - nd2.y;
            er = Math.sqrt(ex*ex + ey*ey); //euclidean distance
            if (er === 0) er = 0.0001;
            fr = rForce(er);
            nd1.dx += ex/er*fr;
            nd1.dy += ey/er*fr;
            nd2.dx -= ex/er*fr;
            nd2.dy -= ey/er*fr;
        }
    }

    //attractive
    for(i = 0; i < edges.length; i++) {
        nd1 = nodes[edges[i].origin];
        nd2 = nodes[edges[i].target];
        ex = nd1.x - nd2.x;
        ey = nd1.y - nd2.y;
        er = Math.sqrt(ex*ex + ey*ey);
        if (er === 0) er = 0.0001;
        fa = aForce(er);
        nd1.dx -= ex/er*fa;
        nd1.dy -= ey/er*fa;
        nd2.dx += ex/er*fa;
        nd2.dy += ey/er*fa;
    }

    for(i = 0; i < polarityEdges.length; i++) {
        nd1 = nodes[polarityEdges[i].origin];
        nd2 = nodes[polarityEdges[i].target];
        ex = nd1.x - nd2.x;
        ey = nd1.y - nd2.y;
        er = Math.sqrt(ex*ex + ey*ey);
        if (er === 0) er = 0.0001;
        fa = aForce(er);
        nd1.dx -= ex/er*fa;
        nd1.dy -= ey/er*fa;
        nd2.dx += ex/er*fa;
        nd2.dy += ey/er*fa;
    }

    //Central
    for (i = 0; i < nodes.length; i++) {
        node = nodes[i];
        ex = canvas.width/2 - node.x;
        ey = canvas.height/2 - node.y;
        er = Math.sqrt(ex*ex + ey*ey);
        if (er === 0) er = 0.0001;
        fa = aForce(er);
        node.dx += ex/er*fa;
        node.dy += ey/er*fa;
    }

    //apply
    for (i = 0; i < nodes.length; i++) {
        er = Math.sqrt(nodes[i].dx * nodes[i].dx + nodes[i].dy * nodes[i].dy);
        nodes[i].x += nodes[i].dx / er * Math.min(er, cooling);
        nodes[i].y += nodes[i].dy / er * Math.min(er, cooling);
    }
    cooling = cooling *.95;
    draw();
    window.requestAFrame(update);
};

window.requestAFrame = (function () {
    return window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
                // if all else fails, use setTimeout
            function (callback) {
                return window.setTimeout(callback, 1000 / 60); // shoot for 60 fps
            };
})();
</script>
</body>
</html>